# xmind
- ###  概述



&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 以前学东西就是遇到什么学什么，学完了从不做记录，最多也就是看到好的技术文章的话就收藏下。时间长了才发现自己似乎什么都懂，又似乎什么都不懂。就是因为自己学习的东西太零散，没有系统的去学习，仅了解到了一个点，正所谓一叶障目，不成体系，就没办法做到融会贯通。再一个是有积累有输入以后还需要有输出，能够把学到的知识内化为自己的知识并将其很好的表述出来那才叫你的知识。为此我在近几年的工作实践中做了不少输出，只是没有在博客中更新。

​       每项技术的历史由来，历史发展，都是为了提高社会生产力而产生。了解一项技术最好方式就是先了解其历史，为什么会有这项技术，它的出现解决了什么问题，在不同时期其内部实现又会存在哪些缺陷，如果是我们自行实现该如何考虑。

​       从 2019 年认识到自己在技术上的无知后就开始奋起直追，知耻而后勇。从那开始凡是看到自己不懂的技术都要找各种资料弄懂，上B站，买书籍，看技术公众号等。B站应该是资料最最最多的地方，上班路上在听它，下班路上也在听它，晚上到家也在听到。周末固定周六一天泡图书馆，恶补技术。一分钟的时间真是巴不得掰成两分钟来花，一看到什么自己不了解的技术点都如获至宝往深处挖。了解的东西多了越是发现自身的渺小，我们需要学习的东西太多太多。

​       在恶补技术期间感觉网络这块应该挺难啃，看了一些公众号的文章后原来也没有那么难，立马把TCP/IP的那三本经典给买了回来。虽然很厚，但是带着问题去看它的话就会发现很有意思。而要是说起算法，那真的就是掉头就走。突然有一天心里在想：没有算法不行呀，试试吧，先试着看看，先到B站看看左神的视频。结果看了两三晚，感觉还不错，也没有多难，都可以听懂。心里又在想：不行啊，光说不练！又开始拿A4来自己练，后面渐渐的才发现算法的魅力。也就有了这个实践 [algorithm](https://github.com/linkypi/algorithm)。

​     每每听到大家说某某框架性能很高，深挖后才知道这些组件都离不开底层的支持，如 redis, nginx, netty 这些底层的网络都离不开IO多路复用 epoll, 当然还有各自内存的优化。如果深挖 TCP/IP 网络，或者平时MQ组件使用的mmap等技术都会发现原来他们都离不开最最底层Linux API的实现, 后悔当初在大学没有学习 Linux/Unix 系统编程及网络编程等底层技术。我们平时知道最多的DB就是MySQL，它比较适合用在读多写少的环境。然而应对高并发环境下的快速随机读写是否还能应对自如？LSM Tree 就在这时候出现了，LevelDB，HBase，Cassandra，InfluxDB，RocksDB 都是采用 LSM Tree 存储模型，Flink 的 State 就是采用的是 RocksDB KV 的存储，还有包括 MongoDB、Cassandra 等等也都基于 RocksDB 的存储引擎而开发。静下心来学习才发现原来很多东西都是相通的，从一个点逐渐延伸到一个面，从一个点就可以看到一片广阔的海洋。

​     《明朝那些事》的作者-当年明月说曾说过一段让我很受触动的话：“这个世界上有很多人有很多种选择，最低的是温饱，然后是利益，就是钱。超越钱的是名望，权利。但是在超越这些所有东西之上，还有一样东西，叫智慧！你到这个世界上来，你应该有这样一个觉悟，就是你终究是要死的，这就是一个人很悲剧的地方。悲剧的地方在于他无论多厉害，无论多牛，无论多么嚣张，他都要死，他都有终结的那一天。那么在这段时间里做什么呢？ 不断的看书，懂得这个世界的很多东西，知道这个世界的规律，那是一种无比的喜悦，狂喜！”


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 这些都是个人近几年技术总结，所有文件均以思维导图（xmind 2020）的方式展现，包含前后端，数据库，分布式，算法等，另外有部分框架的原理分析需要用到一款免费绘图工具[draw.io](https://www.drawio.com/)。不足之处欢迎各位大侠指正，同时也欢迎各位大侠一起探讨及补充。每一个小的知识点都可以发散展开变为一个大的知识面，多个知识面从而形成一个知识体系。

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 路漫漫其修远兮...


- ###  后期

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;后续重点会侧重在分布式架构这块，现在已是大数据时代，几台服务器部署的应用明显已经落后，分布式大数据必将是趋势。同时在面对大规模复杂业务架构方面，我们平时所实现的简单三层架构CRUD显得力不从心，更多的是为了面向数据编程，几乎所有的业务逻辑都由service来完成，缺失面向对象的封装特性。同时往往一个业务逻辑的实现仅有开发者自身可以快速厘清业务逻辑与代码实现的区别，换作他人通过代码来熟悉这部分业务逻辑，那需要的成本将是巨大的。实际技术与业务还隔着一道鸿沟。而理想架构应该是尽量做到业务与代码逻辑的一致性，让代码具备更强的业务表达能力，这就是DDD所追求的目标。DDD 核心思想是通过领域驱动设计方法定义领域模型，从而确定业务和应用边界，保证业务模型与代码模型的一致性。而平时使用的微服务是多微，如何拆分，更是可以借鉴于DDD的领域模型作为微服务拆分的一个重要依据。

